// Day 2: 1202 Program Alarm

import core/math (add, multiply)
import core/text (number_to_text, append)
import core/stopgap/collections (Stack, MaybeStack, Empty, Dictionary, get_item, with_item_at_key, list_entries, KeyValuePair)
import aoc/input (NeedInput, Split, ParseNumber)
import aoc/interface (ReportProgress)
import project/common/collections (at_index, map, map_with_index, for_each_with_index, with_index_set)
import project/common/cast (as_number, as_text)
import project/common/debug (join_text)
import project/common/range (count_inclusive)

function parse_program(text: Text): Dictionary {
  let items = cause Split(text, ",")
  let variable program = Dictionary()
  signal AddItem(index: Number, value: Number): Action
  effect for AddItem as add_item {
    set program = with_item_at_key(program, number_to_text(add_item.index), add_item.value)
  }
  for_each_with_index(items, fn(it: Anything, index: Number) {
    let number = cause ParseNumber(as_text(it))
    cause AddItem(index, number)
  })
  program
}

function debug_memory(memory: Dictionary) {
  let transformed_memory = map(list_entries(memory), fn(it: Anything) {
    let kvp = branch with it {
      is KeyValuePair as kvp2 => kvp2
      else => cause AssumptionBroken("")
    }
    number_to_text(as_number(kvp.value))
  })
  cause Debug(join_text(transformed_memory, ", "))
}

function test() {
  let program = parse_program(cause NeedInput("day02/exampleinput.txt"))
  debug_memory(program)
  let after_memory = run_vm(program)
  debug_memory(after_memory)
}

signal ReadMemory(index: Number): Number
signal WriteMemory(index: Number, value: Number): Action
signal Terminate: NeverContinues

function run_vm(program: Dictionary): Dictionary {
  let variable memory = program
  let variable instruction_pointer = 0

  effect for Terminate {
    return memory
  }
  
  effect for ReadMemory as it {
    as_number(get_item(memory, number_to_text(it.index)))
  }

  effect for WriteMemory as write_memory {
    set memory = with_item_at_key(memory, number_to_text(write_memory.index), write_memory.value)
  }

  loop {
    set instruction_pointer = execute(instruction_pointer)
  }
}

function execute(instruction_pointer: Number): Number {
  let instruction = cause ReadMemory(instruction_pointer)
  branch {
    if equals(instruction, 1) {
      let position_1 = cause ReadMemory(add(instruction_pointer, 1))
      let position_2 = cause ReadMemory(add(instruction_pointer, 2))
      let position_3 = cause ReadMemory(add(instruction_pointer, 3))

      let value_1 = cause ReadMemory(position_1)
      let value_2 = cause ReadMemory(position_2)
      let result = add(value_1, value_2)

      cause WriteMemory(position_3, result)
      add(instruction_pointer, 4)
    }
    if equals(instruction, 2) {
      let position_1 = cause ReadMemory(add(instruction_pointer, 1))
      let position_2 = cause ReadMemory(add(instruction_pointer, 2))
      let position_3 = cause ReadMemory(add(instruction_pointer, 3))

      let value_1 = cause ReadMemory(position_1)
      let value_2 = cause ReadMemory(position_2)
      let result = multiply(value_1, value_2)
      
      cause WriteMemory(position_3, result)
      add(instruction_pointer, 4)
    }
    if equals(instruction, 99) => cause Terminate
    else => cause AssumptionBroken("what is this instruction lol")
  }
}

function part_one() {
    let program = parse_program(cause NeedInput("day02/puzzleinput.txt"))
    let program = with_item_at_key(program, "1", 12)
    let program = with_item_at_key(program, "2", 2)
    let after_memory = run_vm(program)
    get_item(after_memory, "0")
}

function part_two() {
  let program = parse_program(cause NeedInput("day02/puzzleinput.txt"))

  signal FoundAnswer(noun: Number, verb: Number): NeverContinues
  effect for FoundAnswer as found_answer {
    return add(multiply(found_answer.noun, 100), found_answer.verb)
  }

  let MAX = 99

  count_inclusive(0, MAX, fn(i: Number) {
    let noun = i
    count_inclusive(0, MAX, fn(i: Number) {
      let verb = i
      let modified_program = with_item_at_key(program, "1", noun)
      let modified_program = with_item_at_key(modified_program, "2", verb)
      let after_memory = run_vm(modified_program)
      let result = get_item(after_memory, "0")
      // cause Debug(result)
      branch {
        if equals(result, 19690720) => cause FoundAnswer(noun, verb)
        else => {}
      }
    })
    cause ReportProgress(append(append("Handled noun ", number_to_text(noun)), "..."))
  })

  cause AssumptionBroken("Couldn't find a result")
}